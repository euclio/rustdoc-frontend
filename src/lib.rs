//! Frontend for the new [rustdoc] that generates static files.
//!
//! [rustdoc]: https://github.com/steveklabnik/rustdoc

#[macro_use]
extern crate error_chain;

#[macro_use]
extern crate log;

#[macro_use]
extern crate serde_json;

extern crate handlebars;
extern crate jsonapi;
extern crate pathdiff;
extern crate pulldown_cmark;

use std::fs::{self, File};
use std::io::prelude::*;
use std::io;
use std::path::{PathBuf, Path};

use handlebars::Handlebars;
use jsonapi::api::{JsonApiDocument, PrimaryData, IdentifierData, Resource};
use pulldown_cmark::{html, Parser};
use serde_json::Value;

pub mod errors;

/// Given a JSON-API document generated by the rustdoc backend, generates a tree of documentation
/// files at the doc root.
pub fn render_docs<P: AsRef<Path>>(document: &JsonApiDocument, root: P) -> io::Result<()> {
    let mut handlebars = Handlebars::new();

    handlebars
        .register_template_string("item", include_str!("../templates/item.hbs"))
        .unwrap();

    let doc_root = root.as_ref();
    fs::create_dir_all(&doc_root)?;

    // Render the top level crate docs.
    let primary_resource = match document.data {
        Some(PrimaryData::Single(ref resource)) => resource,
        _ => panic!(),
    };

    write_doc(document, &primary_resource, &handlebars, &doc_root)?;

    for resource in document.included.as_ref().unwrap().iter() {
        write_doc(document, &resource, &handlebars, &doc_root)?;
    }

    let mut css = File::create(doc_root.join("styles.css"))?;
    css.write_all(
        include_str!("../static/styles.css").as_bytes(),
    )?;

    let mut js = File::create(doc_root.join("main.js"))?;
    js.write_all(include_str!("../static/main.js").as_bytes())?;

    Ok(())
}

/// Writes a documentation file at the documentation root.
fn write_doc<P: AsRef<Path>>(
    document: &JsonApiDocument,
    resource: &Resource,
    handlebars: &Handlebars,
    doc_root: P,
) -> io::Result<()> {
    let doc_root = doc_root.as_ref();

    if let Some(path) = path_for_resource(resource) {
        let path = doc_root.join(path);
        fs::create_dir_all(path.parent().unwrap())?;
        let mut file = File::create(&path)?;

        info!("rendering `{}` as `{}`", resource.id, path.display());
        let context = generate_context(doc_root, document, resource);
        debug!("context: {}", context);
        let rendered_template = handlebars.render("item", &context).unwrap();
        file.write_all(rendered_template.as_bytes()).unwrap();
    }

    Ok(())
}

/// Generates a context to be used when rendering a resource with handlebars.
fn generate_context(root: &Path, document: &JsonApiDocument, resource: &Resource) -> Value {
    let path_to_root = path_for_resource(resource).and_then(|path| {
        let path = root.join(path);
        html_diff_paths(root, &path)
    });

    let mut context = json!({
        "type": resource._type,
        "name": resource.id,
        "pathToRoot": path_to_root,
    });

    if let Some(docs) = docs_for_resource(&resource) {
        context.as_object_mut().unwrap().insert(
            String::from("docs"),
            Value::String(docs),
        );
    }

    if let Some(relationships) = resource.relationships.as_ref() {
        let mut sections = json!({});

        for (key, data) in relationships {
            let resources = match data.data {
                IdentifierData::Multiple(ref resources) => resources,
                _ => panic!(),
            };

            let json_resources = resources
                .iter()
                .flat_map(|child| {
                    let id = &child.id;

                    let child = resource_by_id(document, id);
                    if child.is_none() {
                        error!(
                            "could not find '{}' in the document's included resources. \
                            This is probably a bug in the rustdoc backend.", id);
                        return None;
                    }
                    let child = child.unwrap();

                    let name = child.id.rsplit("::").next().unwrap_or_else(|| id);

                    // Create a link to the child resource. Since /index.html paths in the
                    // browser actually act like folders, we need to diff the paths from the
                    // parent folder.
                    let link = link(resource, child);

                    let json = json!({
                        "name": name,
                        "link": link,
                        "docs": docs_for_resource(child),
                    });

                    Some(json)
                })
                .collect();

            sections.as_object_mut().unwrap().insert(
                key.clone(),
                Value::Array(
                    json_resources,
                ),
            );

        }

        context.as_object_mut().unwrap().insert(
            String::from("sections"),
            sections,
        );
    }

    context
}

/// Creates a link to a child resource if a page exists for it.
fn link(resource: &Resource, child: &Resource) -> Option<String> {
    match (path_for_resource(resource), path_for_resource(child)) {
        (Some(parent_path), Some(child_path)) => html_diff_paths(&child_path, &parent_path),
        _ => None,
    }
}

/// Returns a path to the doc file for a given resource, if it exists.
///
/// For example, fields do not have individual links.
fn path_for_resource(resource: &Resource) -> Option<PathBuf> {
    let mut path: PathBuf = resource.id.split("::").collect();

    if resource._type == "module" || resource._type == "crate" {
        path.push("index.html");
        Some(path)
    } else {
        let ty = match resource._type.as_str() {
            "struct" => "struct",
            "function" => "fn",
            "trait" => "trait",
            "type" => "type",
            "enum" => "enum",
            "const" => "constant",
            "field" => return None,
            res => unimplemented!("resource {}: {}", res, resource.id),
        };

        let item_name = path.file_name().unwrap().to_owned();
        path.pop();
        path.push(&format!("{}.{}.html", ty, item_name.to_str().unwrap()));
        Some(path)
    }
}

/// Returns the documentation rendered as HTML for a given resource.
fn docs_for_resource(resource: &Resource) -> Option<String> {
    // TODO: We could be smart and do some caching here.
    resource.attributes.get("docs").and_then(|attr| {
        let docs = attr.as_str().expect("docs attribute was not a string");
        let parser = Parser::new(docs);
        let mut rendered_docs = String::new();
        html::push_html(&mut rendered_docs, parser);

        if !rendered_docs.is_empty() {
            Some(rendered_docs)
        } else {
            None
        }
    })
}

/// Given a resource ID, finds the resource in the JSON-API document.
fn resource_by_id<'a>(document: &'a JsonApiDocument, id: &str) -> Option<&'a Resource> {
    document.included.as_ref().and_then(|included| {
        included.iter().find(|resource| resource.id == id)
    })
}

/// Perform a `pathdiff::diff_paths` of two `Path` objects, but return a `String` for HTML output.
///
/// The returned HTML path will differ from a filesystem path in two ways:
///
/// - It will have any backslashed replaced by forward slashes.
/// - It will be relative from the parent folder, not the file itself.
///
/// # Panics
///
/// This function will panic if the `base` parameter does not have a parent, or if any of the path
/// components are invalid UTF-8.
fn html_diff_paths(path: &Path, base: &Path) -> Option<String> {
    let base = base.parent().expect("path did not have a parent");

    pathdiff::diff_paths(path, base).map(|relative_path| {
        relative_path
            .into_iter()
            .map(|component| {
                component.to_str().expect("Path contained invalid UTF-8")
            })
            .collect::<Vec<_>>()
            .join("/")
    })
}

#[cfg(test)]
mod tests {
    use std::path::PathBuf;

    use jsonapi::api::Resource;

    #[test]
    fn path_for_resource() {
        let module = Resource {
            _type: "module".into(),
            id: "test_crate::test_module".into(),
            ..Default::default()
        };

        assert_eq!(
            super::path_for_resource(&module).unwrap(),
            PathBuf::from("test_crate/test_module/index.html")
        );

        let strukt = Resource {
            _type: "struct".into(),
            id: "test_crate::TestStruct".into(),
            ..Default::default()
        };

        assert_eq!(
            super::path_for_resource(&strukt).unwrap(),
            PathBuf::from("test_crate/struct.TestStruct.html")
        );

        let field = Resource {
            _type: "field".into(),
            id: "test_crate::Struct::field".into(),
            ..Default::default()
        };

        assert_eq!(super::path_for_resource(&field), None);
    }

    #[test]
    fn html_diff_paths() {
        let base = PathBuf::from("/target/doc/example/index.html");
        let path = PathBuf::from("/target/doc");
        assert_eq!(super::html_diff_paths(&path, &base), Some("..".into()));
    }
}
